---
title: "ecoliModel"
author: "CRISCI Emma"
date: "2023-05-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Data from PERES Sabine

# Library
```{r}
rm(list = ls())
#library(xlsx)
library(openxlsx)
library(xml2)
library(XML)
library("methods")
library(DIZtools)
library(deSolve)
```


# Data Import

## Parameters import
```{r}
# Définir le nom du fichier xlsx
file <- "param_ecoli_2023.xlsx"

# Lire les noms des feuilles du fichier xls
sheets <- getSheetNames(file)

# Créer une liste pour stocker les données de chaque feuille
parameters <- list()

# Boucle pour parcourir toutes les feuilles du fichier
for (i in 1:length(sheets)) {
  
  # Charger les données de la feuille i dans un dataframe
  df <- read.xlsx(file, sheet = sheets[i], colNames = FALSE)
  
  # Ajouter le dataframe à la liste de données
  parameters[[i]] <- df
}
```
```{r}
names(parameters)<-sheets
```

## XML Import

```{r}
# Read the xml file
ecoliData <- read_xml("ccm_ross.xml")
ecoliData
```


Other way to have different organisation of data
```{r}
ecoliData_xml <- xmlParse("ccm_ross.xml")
```

```{r, echo=FALSE}
xml_data <- xmlToList(ecoliData_xml)  
#print(xml_data) 
```

```{r}
(xml_data$model$listOfCompartments[[2]])
```


## Explication des cinétiques


# Fonction de cinétiques utilisées
```{r}
## Diffusion kinetic ##

# Cext : concentration out
# Cin : concentation in
# kdiff : diffusion constant
r_diffusion <- function(Cext,Cin,kdiff){
  return((Cext-Cin)*kdiff)
}


## Michaelis-Menten Global ##

# kcat (value couple) : c(kcat+, kcat-) kinetic constant
# keq  : kinetic constant
# substrat  : vector of the substrat name of the reaction
# product  : vector of the product name of the reaction
# stochio_substrat : vector of the stochiometric of substrat
# stochio_product : vector of the stochiometric of product

MM_G <- function(kcat,keq,substrat, product, km_substrat, km_product, stochio_substrat, stochio_product){
return(keq* (kcat[1]*prod((substrat/km_substrat)^stochio_substrat)-kcat[2]*prod((product/km_product)^stochio_product))/(1 + prod((substrat/km_substrat)^stochio_substrat)+ prod((product/km_product)^stochio_product)))
}

# MM_G <- function(kcat,keq,substrat, product, km_substrat, km_product, stochio_substrat, stochio_product){
#   numerateur <- keq* (kcat[1]*prod((substrat/km_substrat)^stochio_substrat)-kcat[2]*prod((product/km_product)^stochio_product))
#   print("numérateur ok")
#   denominateur <- (1 + prod((substrat/km_substrat)^stochio_substrat)+ prod((product/km_product)^stochio_product))
#   print("dénominateur ok")
#   return(numerateur/denominateur)
# }
```

```{r}
stochio_product <- c(1,2,3)
product <- c(2,1,4)
km_product <- c(2,3,8)
prod((product/km_product)^stochio_product)
stochio_product[1]
```


# Extractions Of the data
## essais sur le jeu de data

```{r}

(xml_data$model$listOfCompartments[[2]])
```


Récupération de tous les noms de variables


```{r}
# Détermination du nombre de métabolites
nombreMetabo <- as.numeric(length(xml_data$model$listOfSpecies)) # 60 métabolites
nombreReact <- as.numeric(length(xml_data$model$listOfReactions)) # 57 réactions

# Récupération du nom des métabolites
metaboliteName <-c() # name
metaboliteNameMatrix <-c() # id # ATTENTION Dans les réaction on retrouve l'id et pas le nom exacte !!!!
for (i in seq(nombreMetabo)){
  metaboliteName <-c(metaboliteName,xml_data$model$listOfSpecies[[i]][[2]])
  metaboliteNameMatrix <-c(metaboliteNameMatrix,xml_data$model$listOfSpecies[[i]][[1]])

}
(metaboliteName)
(metaboliteNameMatrix)

# Récupération du nom des réactions 
reactionName <-c() # name
enzymeName <-c() # id # ATTENTION Dans les réaction on retrouve l'id et pas le nom exacte !!!!
for (i in seq(nombreReact)){
  reactionName <-c(reactionName,xml_data$model$listOfReactions[[i]][[3]][[1]])
  enzymeName <-c(enzymeName,xml_data$model$listOfReactions[[i]][[3]][[2]])

}
(reactionName)
(enzymeName)
```
```{r}
(xml_data$model$listOfReactions[[1]][[3]][[1]])

```

# Matrice de Stochiométrie
```{r}
# Initialistion de la matrice 

# Avec en ligne l'id des molécules et en colones le nom de la réaction
matrix_sto_ode <- matrix(0,nrow = nombreMetabo, ncol = nombreReact)
colnames(matrix_sto_ode) <- enzymeName
rownames(matrix_sto_ode) <- metaboliteNameMatrix

#matrix_sto_ode['M_ACETATE_ext',1] <- 5
```

```{r}
# Remplissage de la matrice 
#print(nombreReact)
# Pour chaque réaction 
for (numReact in seq(nombreReact)){
  #print(numReact)
  # Récupération des ## Substrats ##
  for (reactant in seq(length(xml_data$model$listOfReactions[[numReact]][[1]]))){
    #print(reactant)
    # Pour chaque réactant :
    # on récupère l'id et la stochiométrie
    nameReactant <- as.character(xml_data$model$listOfReactions[[numReact]][[1]][[reactant]][[1]]) # id de la molécule (avec m_ devant)
    stochioReactant <- - as.numeric(xml_data$model$listOfReactions[[numReact]][[1]][[reactant]][[2]])
    #print(nameReactant)
    #print(stochioReactant)
    #print("")
    
    # Ajout dans la matrice
    matrix_sto_ode[nameReactant,numReact] <-  stochioReactant # Attention Signe négatif car ici on consome la molécule
  }
  
    # Récupération des ## PRODUITS ##
  for (reactant in seq(length(xml_data$model$listOfReactions[[numReact]][[2]]))){
    # Pour chaque réactant :
    
    # on récupère l'id et la stochiométrie
    nameReactant <- as.character(xml_data$model$listOfReactions[[numReact]][[2]][[reactant]][[1]]) # id de la molécule (avec m_ devant)
    stochioReactant <- as.numeric(xml_data$model$listOfReactions[[numReact]][[2]][[reactant]][[2]])
    
    # Ajout dans la matrice
    matrix_sto_ode[nameReactant,numReact] <- stochioReactant
  }
}

```




# Écriture du système


# Déterminer les réactions de diffusion 
```{r}
nomReactDiff <- gsub("ex_","",parameters$diffusion$X1) # "CO2"  "ETOH" "O2"  
# quand ces id deréactifs sont présent en réactifs alors c'est une loi de diffusion sinon c'est MM généralisé

reactDiff <- paste("M_",nomReactDiff,sep="")
reactDiff <- paste(reactDiff,"_ext",sep="")
```


```{r}
xml_data$model$listOfReactions[[5]][[2]]
```


```{r}
xml_data$model$listOfReactions[[4]][[2]]
```




# Implémentation fonction syst
```{r}
syst <- function(t,y,parameters, msys){
  
  # Construction des Phi
  
  # Initialisation de la matrice
  matrix_phi <- matrix(0,nrow = ncol(msys)) # correspond au nombre de reactions
  # Remplissage de la matrice 
  for (numReact in seq(nombreReact)){
    # pour chaque réaction on lui assigne un phi

    print("Numéro de réaction")
    print(numReact)
    ## 1. récupérer les informations sur cette réaction. ##
    
    # Paramètres constants => restent constants => VOIR LA REPONSE DE SABINE SINON REATRIBUER A Y[1:7] les valeurs du excel à chaque tour

    # Récupération des ## Substrats ##
    r_substrats  = c()
    r_stochioSub = c()
    for (reactant in seq(length(xml_data$model$listOfReactions[[numReact]][[1]]))){
        # on récupère l'id 
      r_substrats  <- c(r_substrats, as.character(xml_data$model$listOfReactions[[numReact]][[1]][[reactant]][[1]])) # id de la molécule (avec M_ devant)
      r_stochioSub <- c(r_stochioSub, as.numeric(xml_data$model$listOfReactions[[numReact]][[1]][[reactant]][[2]])) # stochio
    }
    #print("Nom des substrats")
    #print(r_substrats)
    # Récupération des ## PRODUITS ##
    r_produits    = c()
    r_stochioProd = c()
    for (reactant in seq(length(xml_data$model$listOfReactions[[numReact]][[2]]))){
    # Pour chaque réactant :
      # on récupère l'id 
      #print("Numéro de réactant")
      #print(reactant)
      r_produits    <- c(r_produits, as.character(xml_data$model$listOfReactions[[numReact]][[2]][[reactant]][[1]])) # id de la molécule (avec m_ devant)
      #print("passage 3")
      r_stochioProd <- c(r_stochioProd , as.numeric(xml_data$model$listOfReactions[[numReact]][[2]][[reactant]][[2]]))

    }

    
    # Détermination du type d'équation à utiliser suivant les cas : on regarde si on retrouve reactDiff
    interSub  <- intersect(r_substrats,reactDiff)
    interProd <- intersect(r_produits,reactDiff)
    
    #print("passage 4")
    if (is.empty(interProd) & is.empty(interSub)){
      print("MM_G")
      # Si on est pas dans un cas ou il y a de la diffusion alors on a un MM généralisé
      
      ## Michaelis Menten Kinetics ##
      
      # kcat (value couple) : c(kcat+, kcat-) kinetic constant
      # keq  : kinetic constant
      # substrat  : vector of the substrat name of the reaction
      # product  : vector of the product name of the reaction
      # stochio_substrat : vector of the stochiometric of substrat
      # stochio_product : vector of the stochiometric of product
      
      nomEnzyme <- gsub("R_","",reactionName[numReact]) # id de la réaction : R_ack => nom de l'enzyme 
      print("Nom Enzyme")
      print(nomEnzyme)
      
      # Recherche des valeurs 
      kcat <- c(as.numeric(subset(parameters$kcat,X1==nomEnzyme)[[2]]),as.numeric(subset(parameters$kcat,X1==nomEnzyme)[[3]]))
      keq  <- as.numeric(subset(parameters$keq,X1==nomEnzyme)[[2]])
      # print("rechercher des kcat et keq finie")
      # print("kcat et keq")
      # print(kcat)
      # print(keq)
      print("Nom des substrats et Produits")
      print(r_substrats)
      print(r_produits)
      
      substrat <- y[match(r_substrats,metaboliteNameMatrix)] # on cherche le numéro de réactif, r_substrats,r_produits donne le nom.
      product  <- y[match(r_produits,metaboliteNameMatrix)]
      
      ##
      # print("Valeur des substrats et produits pour Y")
      # print(substrat)
      # print(product)
      ##
      
      km_substrat <- c()
      for (sub in r_substrats){
        # print("ICI")
        # print(sub)
        reelSubstractName <- gsub("M_","",sub)
        namekm            <- paste("km_" ,paste(nomEnzyme,reelSubstractName,sep="_"),sep="")
        #print(namekm)
        km_substrat       <- c(km_substrat,as.numeric(subset(parameters$km,X1==namekm)[[2]]))
        #print(as.numeric(subset(parameters$km,X1==namekm)[[2]]))
      }
      km_product  <- c()
      for (prod in r_produits){
        # print("ICI")
        # print(prod)
        reelProduitName <- gsub("M_","",prod)
        namekm          <- paste("km_" ,paste(nomEnzyme,reelProduitName,sep="_"),sep="")
        #print(namekm)
        km_product      <- c(km_product,as.numeric(subset(parameters$km,X1==namekm)[[2]]))
        #print(as.numeric(subset(parameters$km,X1==namekm)[[2]]))

      }
      print("Valeur des km")
      print(km_substrat)
      print(km_product)
      
      stochio_substrat <- r_stochioSub
      stochio_produit  <- r_stochioProd
      
      print("Valeur Stochiométrie")
      print(stochio_substrat)
      print(stochio_produit)
      # on a tous les éléments pour appeller a fonction
           
      matrix_phi[numReact,1] <-MM_G(kcat,keq,substrat, product, km_substrat, km_product, stochio_substrat, stochio_produit)
      print("fin application à la matrice")
      view(matrix_phi)
    }
    else{
      # on est dans le cas où on a une diffusion car on le retrouve dans la liste des réactifs avec une diffusion
      print("Diffusion")
      
      ## Diffusion kinetic ##

      # Cext : concentration out
      # Cin : concentation in
      # kdiff : diffusion constant
      print("intersection")
      print(interSub)
      print(interProd)
      # Recherche des noms des réactifs
      nameCext      <- c(interSub, interProd) # on cherche le nom de la constante en utilisant les résultats des intersections type : M_CO2_ext
      print("nameCext")
      print(nameCext)
      
      nameCint      <- c(setdiff(r_produits,nameCext),setdiff(r_substrats,nameCext)) # on utilise U pour avoir l'autre réactif type : M_ADP
      print("nom des autres réactifs")
      print(r_produits)
      print(r_substrats)
      print(nameCint)
      nameParaDiff  <- paste("ex_", gsub("_ext","",gsub("M_","",nameCext)), sep="")
      

      # On cherche les valeurs des paramètres :
      
      valueCext <- y[match(nameCext,metaboliteNameMatrix)] # on va chercher le bon y
      
      # valueCext <- as.numeric(subset(parameters$ext,X1==gsub("M_","",nameCext))[[2]] ) #On va chercher la constante dans la table de données # SI CONSTANTE 
      valueCint <- y[match(nameCint,metaboliteNameMatrix)] # on cherche le numero du métabolitepour assigner x[0], x[...]
      kdiff     <- as.numeric(subset(parameters$diffusion,X1==nameParaDiff)[[2]] )
      
      print("Valeurs de la fonction")
      print(valueCext)
      print(valueCint)
      print(kdiff)
      # On a tout pour constituer le phi de diffusion : application de la fonction de diffusion
      matrix_phi[numReact,1] <-r_diffusion(valueCext,valueCint,kdiff)
      
    }
  }
  
  # Fin de la construction de la matrice des Phi
  
  # Mise à jour des équations
  dy <- msys %*% matrix_phi
  
  return(list(as.vector(dy)))
}
```

# modélisation

## Condition initiales
Essai 1 : on considère que aucun métabolite intérieur ou extérieur est constant 

Importation des données de condition initiales
```{r}
# Définir le nom du fichier xlsx
file <- "init.xlsx"

# Lire les noms des feuilles du fichier xls
sheets <- getSheetNames(file)

# Créer une liste pour stocker les données de chaque feuille
initData <- list()

# Boucle pour parcourir toutes les feuilles du fichier
for (i in 1:length(sheets)) {
  
  # Charger les données de la feuille i dans un dataframe
  df <- read.xlsx(file, sheet = sheets[i])
  
  # Ajouter le dataframe à la liste de données
  initData[[i]] <- df
}

names(initData)<-sheets
```

Extraction des données intéressantes de condition initiales pour la résolution

On récupère dans l'ordre les concentrations initiales
```{r}
init <- c()
for (metabolite in metaboliteNameMatrix){
  init <- c(init,as.numeric(subset(initData$Metabolites,Metabolite==gsub("M_","",metabolite))[[2]]))
}
```


```{r}
initview <- as.data.frame(init)
rownames(initview)<- metaboliteNameMatrix
```


## Time Range
```{r}
time <- seq(0, 100, by=0.02)
```

## Resolution

```{r}
xml_data$model$listOfReactions[[5]][[1]][[1]]
```


```{r}

solutionODElsoda <- lsoda(y = init, times = time, func = syst, parms = parameters , msys = matrix_sto_ode)
```










